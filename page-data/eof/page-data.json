{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/eof/",
    "result": {"data":{"cur":{"id":"72bfe130-275b-59bb-bcce-f6b57fa8696f","html":"<h1 id=\"eof\" style=\"position:relative;\"><a href=\"#eof\" aria-label=\"eof permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>EOF</h1>\n<p>가끔 백준 알고리즘 문제를 풀다보면 입력의 마지막 조건을 알려주지 않는 문제들이 있다.</p>\n<p>이럴 때 사용하는 케이스들을 정리하려고 한다.</p>\n<h2 id=\"1-scanf가-입력받은-인자의-갯수를-리턴하는-특성-활용\" style=\"position:relative;\"><a href=\"#1-scanf%EA%B0%80-%EC%9E%85%EB%A0%A5%EB%B0%9B%EC%9D%80-%EC%9D%B8%EC%9E%90%EC%9D%98-%EA%B0%AF%EC%88%98%EB%A5%BC-%EB%A6%AC%ED%84%B4%ED%95%98%EB%8A%94-%ED%8A%B9%EC%84%B1-%ED%99%9C%EC%9A%A9\" aria-label=\"1 scanf가 입력받은 인자의 갯수를 리턴하는 특성 활용 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. scanf()가 입력받은 인자의 갯수를 리턴하는 특성 활용</h2>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;cstdio></span></span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token function\">scanf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d %d\"</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>b<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\n        <span class=\"token comment\">// scanf는 입력받은 갯수를 리턴한다.</span>\n        <span class=\"token comment\">// 만약에 scanf(\"%d\",&amp;a); 에서 입력이 제대로 들어왔다면 1이 리턴된다.</span>\n        <span class=\"token comment\">// 그렇기 때문에 a,b를 입력받는 scanf가 2와 같다면이란 말은 입력이 있다면과 같은 말이다.</span>\n        \n        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d\\n\"</span><span class=\"token punctuation\">,</span> a <span class=\"token operator\">+</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>scanf()는 입력받은 갯수를 리턴하기 때문에 이를 활용하여 입력을 받았는지 확인할 수 있다.</p>\n<h2 id=\"2-scanf를-eof와-직접-비교\" style=\"position:relative;\"><a href=\"#2-scanf%EB%A5%BC-eof%EC%99%80-%EC%A7%81%EC%A0%91-%EB%B9%84%EA%B5%90\" aria-label=\"2 scanf를 eof와 직접 비교 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. scanf()를 EOF와 직접 비교</h2>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> a<span class=\"token punctuation\">,</span>b<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token function\">scanf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d %d\"</span><span class=\"token punctuation\">,</span><span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">,</span><span class=\"token operator\">&amp;</span>b<span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token constant\">EOF</span><span class=\"token punctuation\">)</span>\n        <span class=\"token comment\">// EOF == End Of File</span>\n        <span class=\"token comment\">// 말그대로 파일의 끝에 도달하면 EOF를 리턴한다.</span>\n        <span class=\"token comment\">// 윈도우 계열에서 임의로 발생시키기 위해선 Ctrl + Z를 누르면 된다. </span>\n        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d\\n\"</span><span class=\"token punctuation\">,</span>a<span class=\"token operator\">+</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>EOF = End Of File을 뜻한다.</p>\n<p>즉, 파일의 끝에 도달했는지 확인하여 입력을 받았는지 확인할 수 있다.</p>\n<h2 id=\"3-eof가-상수--1로-정의되어-있는-특성-활용\" style=\"position:relative;\"><a href=\"#3-eof%EA%B0%80-%EC%83%81%EC%88%98--1%EB%A1%9C-%EC%A0%95%EC%9D%98%EB%90%98%EC%96%B4-%EC%9E%88%EB%8A%94-%ED%8A%B9%EC%84%B1-%ED%99%9C%EC%9A%A9\" aria-label=\"3 eof가 상수  1로 정의되어 있는 특성 활용 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. EOF가 상수 -1로 정의되어 있는 특성 활용</h2>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;cstdio></span></span>\n<span class=\"token keyword\">int</span> a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token function\">scanf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d %d\"</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>b<span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d\\n\"</span><span class=\"token punctuation\">,</span> a <span class=\"token operator\">+</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 'EOF 리턴하기 전까지는 계속 돌아'와 같은 말. EOF는 상수 -1로 정의되어 있기 때문!</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>EOF는 상수 -1로 정의 되어 있기 때문에 EOF인지 확인하는 방법과 -1인지 확인하는 방법이 같다.</p>\n<h2 id=\"4-cineof-활용\" style=\"position:relative;\"><a href=\"#4-cineof-%ED%99%9C%EC%9A%A9\" aria-label=\"4 cineof 활용 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. cin.eof() 활용</h2>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;iostream></span></span>\n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\n \n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n   <span class=\"token keyword\">int</span> a<span class=\"token punctuation\">,</span>b<span class=\"token punctuation\">;</span>\n \n   <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n       cin <span class=\"token operator\">>></span> a <span class=\"token operator\">>></span> b<span class=\"token punctuation\">;</span>\n       <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>cin<span class=\"token punctuation\">.</span><span class=\"token function\">eof</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// cin으로 입력받은 값이 없으면</span>\n        <span class=\"token comment\">// cin.eof()는 true를 반환한다. 당연히 그렇지 않으면 false 반환</span>\n           <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n       <span class=\"token punctuation\">}</span>\n       cout <span class=\"token operator\">&lt;&lt;</span> a <span class=\"token operator\">+</span> b <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n   <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>cin으로 입력 받은 값이 없으면 cin.eof()는 true를 반환한다. 이것을 활용하여 입력을 받았는지 확인할 수 있다.</p>\n<h1 id=\"참조\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EC%A1%B0\" aria-label=\"참조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참조</h1>\n<p><a href=\"https://takeknowledge.tistory.com/20\">C++ EOF 처리 방법 ( 백준 10951 A+B - 4 ) (tistory.com)</a></p>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#1-scanf%EA%B0%80-%EC%9E%85%EB%A0%A5%EB%B0%9B%EC%9D%80-%EC%9D%B8%EC%9E%90%EC%9D%98-%EA%B0%AF%EC%88%98%EB%A5%BC-%EB%A6%AC%ED%84%B4%ED%95%98%EB%8A%94-%ED%8A%B9%EC%84%B1-%ED%99%9C%EC%9A%A9\">1. scanf()가 입력받은 인자의 갯수를 리턴하는 특성 활용</a></li>\n<li><a href=\"#2-scanf%EB%A5%BC-eof%EC%99%80-%EC%A7%81%EC%A0%91-%EB%B9%84%EA%B5%90\">2. scanf()를 EOF와 직접 비교</a></li>\n<li><a href=\"#3-eof%EA%B0%80-%EC%83%81%EC%88%98--1%EB%A1%9C-%EC%A0%95%EC%9D%98%EB%90%98%EC%96%B4-%EC%9E%88%EB%8A%94-%ED%8A%B9%EC%84%B1-%ED%99%9C%EC%9A%A9\">3. EOF가 상수 -1로 정의되어 있는 특성 활용</a></li>\n<li><a href=\"#4-cineof-%ED%99%9C%EC%9A%A9\">4. cin.eof() 활용</a></li>\n</ul>\n</div>","excerpt":"EOF 가끔 백준 알고리즘 문제를 풀다보면 입력의 마지막 조건을 알려주지 않는 문제들이 있다. 이럴 때 사용하는 케이스들을 정리하려고 한다. 1. scanf()가 입력받은 인자의 갯수를 리턴하는 특성 활용 scanf()는 입력받은 갯수를 리턴하기 때문에 이를 활용하여 입력을 받았는지 확인할 수 있다. 2. scanf()를 EOF와 직접 비교 EOF = End Of File을 뜻한다. 즉, 파일의 끝에 도달했는지 확인하여 입력을 받았는지 확인할 수 있다. 3. EOF가 상수 -1로 정의되어 있는 특성 활용 EOF는 상수 -1로 정의 되어 있기 때문에 EOF인지 확인하는 방법과 -1인지 확인하는 방법이 같다. 4. cin.eof() 활용 cin으로 입력 받은 값이 없으면 cin.eof()는 true를 반환한다. 이것을 활용하여 입력을 받았는지 확인할 수 있다. 참조 C++ EOF 처리 방법 ( 백준 10951 A+B - 4 ) (tistory.com) 1. scanf()가 입력받은 인…","frontmatter":{"date":"January 27, 2022","title":"EOF","categories":"C\\+\\+","author":"JaeseokWoo","emoji":"⌨️"},"fields":{"slug":"/eof/"}},"next":{"id":"66f3daff-3936-54ed-a88e-cb5ff3597846","html":"<p>유클리드 호제법 또는 유클리드 알고리즘은 2개의 자연수의 최대공약수를 구하는 알고리즘의 하나이다.</p>\n<p>호제법이란? 두 수를 나누어 결국 원하는 수를 얻는 알고리즘을 나타낸다.</p>\n<h3 id=\"정의\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EC%9D%98\" aria-label=\"정의 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정의</h3>\n<p>2개의 자연수 a, b에 대해서 a를 b로 나눈 나머지를 r이라 하면 a와 b의 최대공약수는 b와 r의 최대공약수와 같다.</p>\n<h3 id=\"정리\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EB%A6%AC\" aria-label=\"정리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정리</h3>\n<p>a와 b의 최대공약수를 (a, b) = r이라고 하면</p>\n<p>(a, b) = (b, r)</p>\n<h3 id=\"예제\" style=\"position:relative;\"><a href=\"#%EC%98%88%EC%A0%9C\" aria-label=\"예제 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>📝예제</h3>\n<p>(1071, 1029) = (1029, 42) = (42, 21) = (21, 0) = 21</p>\n<h3 id=\"증명\" style=\"position:relative;\"><a href=\"#%EC%A6%9D%EB%AA%85\" aria-label=\"증명 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>증명</h3>\n<p>a, b가 정수이고 a≥b라고 하자.</p>\n<p>그러면 a = bq + r을 만족하는 유일한 q, r이 존재한다. (0≤ r &#x3C; b)</p>\n<p>(a, b)의 최대공약수가 d이면,</p>\n<p>a = dα, b = dβ이고 α, β는 서로소(최대공약수가 1)이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">a = bq + r\n=> dα = dβq + r // a = dα, b = dβ 대입\n=> r = d(α-βq) // 이항 &amp; d로 묶기\n\n그러면,\nr = d(α-βq), b = dβ이고 둘 사이에는 d라는 공통의 약수가 있다는 것입니다.\n\n이제 r와 b의 최대공약수가 d라는 것을 증명하면, a, b의 최대공약수와 같다는 것을 알 수 있습니다.\nr와 b의 최대공약수가 d인 것을 증명하려면\nα-βq와 β가 서로소라는 사실을 증명하면 됩니다.\n\n여기서 서로소를 증명하기 위해\n'서로소가 아니다'라는 사실이 틀렸음을 보이면 됩니다.\n즉, 서로소가 아니게 가정을 했을 때 모순이 발생하면 틀린 것입니다.\n== 이러한 방법을 귀류법이라고 합니다.\n\n서로소가 아니라고 가정을 했기때문에\n둘 사이에 1보다 큰 최대공약수 t가 존재합니다.\nα-βq = mt, β = nt\n=> α-ntq = mt // β = nt을 대입\n=> α = t(nq+m)\n\n여기서 모순이 발생합니다.\n바로 위에서 α, β는 서로소인데, 결과는 서로소가 아니라고 나오기 때문입니다.\nα = t(nq+m)\nβ = nt\n\n따라서 α-βq와 β가 서로소이고 a, b의 최대공약수 d는 b, r의 최대공약수와 같습니다.</code></pre></div>\n<h3 id=\"알고리즘\" style=\"position:relative;\"><a href=\"#%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\" aria-label=\"알고리즘 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>알고리즘</h3>\n<p>알고리즘을으로 나타내면 다음과 같습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">int</span> <span class=\"token function\">gcb</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> b<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>b <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> a<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">return</span> <span class=\"token function\">gcb</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">,</span> a<span class=\"token operator\">%</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2 id=\"참조\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EC%A1%B0\" aria-label=\"참조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참조</h2>\n<p><a href=\"https://sseong40.tistory.com/3\">썽 :: [대수학&#x26;정수론]유클리드 호제법의 증명 (tistory.com)</a></p>\n<p><a href=\"https://ko.wikipedia.org/wiki/%EC%9C%A0%ED%81%B4%EB%A6%AC%EB%93%9C_%ED%98%B8%EC%A0%9C%EB%B2%95\">유클리드 호제법 - 위키백과, 우리 모두의 백과사전 (wikipedia.org)</a></p>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<ul>\n<li><a href=\"#%EC%A0%95%EC%9D%98\">정의</a></li>\n<li><a href=\"#%EC%A0%95%EB%A6%AC\">정리</a></li>\n<li><a href=\"#%EC%98%88%EC%A0%9C\">📝예제</a></li>\n<li><a href=\"#%EC%A6%9D%EB%AA%85\">증명</a></li>\n<li><a href=\"#%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\">알고리즘</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%B0%B8%EC%A1%B0\">참조</a></p>\n</li>\n</ul>\n</div>","frontmatter":{"date":"January 22, 2022","title":"Euclidean algorithm","categories":"Algorithm","author":"JaeseokWoo","emoji":"🧩"},"fields":{"slug":"/euclidean-algorithm/"}},"prev":null,"site":{"siteMetadata":{"siteUrl":"https://jaeseokwoo.github.io","comments":{"utterances":{"repo":"JaeseokWoo/JaeseokWoo.github.io"}}}}},"pageContext":{"slug":"/eof/","nextSlug":"/euclidean-algorithm/","prevSlug":""}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}