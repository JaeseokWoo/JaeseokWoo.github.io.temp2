{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/euclidean-algorithm/",
    "result": {"data":{"cur":{"id":"66f3daff-3936-54ed-a88e-cb5ff3597846","html":"<p>유클리드 호제법 또는 유클리드 알고리즘은 2개의 자연수의 최대공약수를 구하는 알고리즘의 하나이다.</p>\n<p>호제법이란? 두 수를 나누어 결국 원하는 수를 얻는 알고리즘을 나타낸다.</p>\n<h3 id=\"정의\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EC%9D%98\" aria-label=\"정의 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정의</h3>\n<p>2개의 자연수 a, b에 대해서 a를 b로 나눈 나머지를 r이라 하면 a와 b의 최대공약수는 b와 r의 최대공약수와 같다.</p>\n<h3 id=\"정리\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EB%A6%AC\" aria-label=\"정리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정리</h3>\n<p>a와 b의 최대공약수를 (a, b) = r이라고 하면</p>\n<p>(a, b) = (b, r)</p>\n<h3 id=\"예제\" style=\"position:relative;\"><a href=\"#%EC%98%88%EC%A0%9C\" aria-label=\"예제 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>📝예제</h3>\n<p>(1071, 1029) = (1029, 42) = (42, 21) = (21, 0) = 21</p>\n<h3 id=\"증명\" style=\"position:relative;\"><a href=\"#%EC%A6%9D%EB%AA%85\" aria-label=\"증명 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>증명</h3>\n<p>a, b가 정수이고 a≥b라고 하자.</p>\n<p>그러면 a = bq + r을 만족하는 유일한 q, r이 존재한다. (0≤ r &#x3C; b)</p>\n<p>(a, b)의 최대공약수가 d이면,</p>\n<p>a = dα, b = dβ이고 α, β는 서로소(최대공약수가 1)이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">a = bq + r\n=> dα = dβq + r // a = dα, b = dβ 대입\n=> r = d(α-βq) // 이항 &amp; d로 묶기\n\n그러면,\nr = d(α-βq), b = dβ이고 둘 사이에는 d라는 공통의 약수가 있다는 것입니다.\n\n이제 r와 b의 최대공약수가 d라는 것을 증명하면, a, b의 최대공약수와 같다는 것을 알 수 있습니다.\nr와 b의 최대공약수가 d인 것을 증명하려면\nα-βq와 β가 서로소라는 사실을 증명하면 됩니다.\n\n여기서 서로소를 증명하기 위해\n'서로소가 아니다'라는 사실이 틀렸음을 보이면 됩니다.\n즉, 서로소가 아니게 가정을 했을 때 모순이 발생하면 틀린 것입니다.\n== 이러한 방법을 귀류법이라고 합니다.\n\n서로소가 아니라고 가정을 했기때문에\n둘 사이에 1보다 큰 최대공약수 t가 존재합니다.\nα-βq = mt, β = nt\n=> α-ntq = mt // β = nt을 대입\n=> α = t(nq+m)\n\n여기서 모순이 발생합니다.\n바로 위에서 α, β는 서로소인데, 결과는 서로소가 아니라고 나오기 때문입니다.\nα = t(nq+m)\nβ = nt\n\n따라서 α-βq와 β가 서로소이고 a, b의 최대공약수 d는 b, r의 최대공약수와 같습니다.</code></pre></div>\n<h3 id=\"알고리즘\" style=\"position:relative;\"><a href=\"#%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\" aria-label=\"알고리즘 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>알고리즘</h3>\n<p>알고리즘을으로 나타내면 다음과 같습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">int</span> <span class=\"token function\">gcb</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> b<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>b <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> a<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">return</span> <span class=\"token function\">gcb</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">,</span> a<span class=\"token operator\">%</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2 id=\"참조\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EC%A1%B0\" aria-label=\"참조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참조</h2>\n<p><a href=\"https://sseong40.tistory.com/3\">썽 :: [대수학&#x26;정수론]유클리드 호제법의 증명 (tistory.com)</a></p>\n<p><a href=\"https://ko.wikipedia.org/wiki/%EC%9C%A0%ED%81%B4%EB%A6%AC%EB%93%9C_%ED%98%B8%EC%A0%9C%EB%B2%95\">유클리드 호제법 - 위키백과, 우리 모두의 백과사전 (wikipedia.org)</a></p>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<ul>\n<li><a href=\"#%EC%A0%95%EC%9D%98\">정의</a></li>\n<li><a href=\"#%EC%A0%95%EB%A6%AC\">정리</a></li>\n<li><a href=\"#%EC%98%88%EC%A0%9C\">📝예제</a></li>\n<li><a href=\"#%EC%A6%9D%EB%AA%85\">증명</a></li>\n<li><a href=\"#%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\">알고리즘</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%B0%B8%EC%A1%B0\">참조</a></p>\n</li>\n</ul>\n</div>","excerpt":"유클리드 호제법 또는 유클리드 알고리즘은 2개의 자연수의 최대공약수를 구하는 알고리즘의 하나이다. 호제법이란? 두 수를 나누어 결국 원하는 수를 얻는 알고리즘을 나타낸다. 정의 2개의 자연수 a, b에 대해서 a를 b로 나눈 나머지를 r이라 하면 a와 b의 최대공약수는 b와 r의 최대공약수와 같다. 정리 a와 b의 최대공약수를 (a, b) = r이라고 하면 (a, b) = (b, r) 📝예제 (1071, 1029) = (1029, 42) = (42, 21) = (21, 0) = 21 증명 a, b가 정수이고 a≥b라고 하자. 그러면 a = bq + r을 만족하는 유일한 q, r이 존재한다. (0≤ r < b) (a, b)의 최대공약수가 d이면, a = dα, b = dβ이고 α, β는 서로소(최대공약수가 1)이다. 알고리즘 알고리즘을으로 나타내면 다음과 같습니다. 참조 썽 :: [대수학&정수론]유클리드 호제법의 증명 (tistory.com) 유클리드 호제법 - 위키백과, 우리 모두…","frontmatter":{"date":"January 22, 2022","title":"Euclidean algorithm","categories":"Algorithm","author":"JaeseokWoo","emoji":"🧩"},"fields":{"slug":"/euclidean-algorithm/"}},"next":{"id":"c3706ced-92da-5fe3-b2c5-91754f6e00f9","html":"<p>n이 양의 정수일 때, ϕ(<em>n</em>)를 구하는 함수이다.</p>\n<p>ϕ(<em>n</em>)은 1부터 n까지의 n과 서로소(최대공약수가 1인 관계)인 수를 나타낸다.</p>\n<h2 id=\"항등식\" style=\"position:relative;\"><a href=\"#%ED%95%AD%EB%93%B1%EC%8B%9D\" aria-label=\"항등식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>항등식</h2>\n<p>만약 두 정수 m, n이 서로소라면, 다음이 성립힌다.</p>\n<p>ϕ(mn) = ϕ(m)ϕ(<em>n</em>)</p>\n<p>오일러 피 함수 값은 소인수(소수의 인수)를 통해  다음과 같이 구할 수 있다.</p>\n<p><img src=\"https://wikimedia.org/api/rest_v1/media/math/render/svg/f435f9cc2f15d34d49245f30d4d85a8cc678fa9d\" alt=\"https://wikimedia.org/api/rest_v1/media/math/render/svg/f435f9cc2f15d34d49245f30d4d85a8cc678fa9d\"></p>\n<p>오일러 곱 공식이라고 불린다.</p>\n<h3 id=\"-예제\" style=\"position:relative;\"><a href=\"#-%EC%98%88%EC%A0%9C\" aria-label=\" 예제 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>📝 예제</h3>\n<p><img src=\"https://wikimedia.org/api/rest_v1/media/math/render/svg/3ec5709cc7b8119ce7526f223fb42bfd84304286\" alt=\"https://wikimedia.org/api/rest_v1/media/math/render/svg/3ec5709cc7b8119ce7526f223fb42bfd84304286\"></p>\n<h3 id=\"알고리즘\" style=\"position:relative;\"><a href=\"#%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\" aria-label=\"알고리즘 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>알고리즘</h3>\n<ol>\n<li>1부터 n까지 증가하면서 최대공약수가 1인 확인하여 구하는 방법</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">int</span> <span class=\"token function\">gcd</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> b<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>b <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> a<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">gcd</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">,</span> a <span class=\"token operator\">%</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">phi</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> result <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">gcd</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n            result<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ol start=\"2\">\n<li>오일러 곱 공식 구현</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">int</span> <span class=\"token function\">phi</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n     \n    <span class=\"token comment\">// Initialize result as n</span>\n    <span class=\"token keyword\">float</span> result <span class=\"token operator\">=</span> n<span class=\"token punctuation\">;</span>\n  \n    <span class=\"token comment\">// Consider all prime factors of n</span>\n    <span class=\"token comment\">// and for every prime factor p,</span>\n    <span class=\"token comment\">// multiply result with (1 - 1/p)</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> p <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span> p <span class=\"token operator\">*</span> p <span class=\"token operator\">&lt;=</span> n<span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>p<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n         \n        <span class=\"token comment\">// Check if p is a prime factor.</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">%</span> p <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n             \n            <span class=\"token comment\">// If yes, then update n and result</span>\n            <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">%</span> p <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n                n <span class=\"token operator\">/=</span> p<span class=\"token punctuation\">;</span>\n                 \n            result <span class=\"token operator\">*=</span> <span class=\"token punctuation\">(</span><span class=\"token number\">1.0</span> <span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span><span class=\"token number\">1.0</span> <span class=\"token operator\">/</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">float</span><span class=\"token punctuation\">)</span>p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  \n    <span class=\"token comment\">// If n has a prime factor greater than sqrt(n)</span>\n    <span class=\"token comment\">// (There can be at-most one such prime factor)</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">></span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n        result <span class=\"token operator\">*=</span> <span class=\"token punctuation\">(</span><span class=\"token number\">1.0</span> <span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span><span class=\"token number\">1.0</span> <span class=\"token operator\">/</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">float</span><span class=\"token punctuation\">)</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  \n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span>result<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ol start=\"3\">\n<li>위의 float 사용하지 않는 방법</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">int</span> <span class=\"token function\">phi</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// Initialize result as n</span>\n    <span class=\"token keyword\">int</span> result <span class=\"token operator\">=</span> n<span class=\"token punctuation\">;</span>\n  \n    <span class=\"token comment\">// Consider all prime factors of n</span>\n    <span class=\"token comment\">// and subtract their multiples</span>\n    <span class=\"token comment\">// from result</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> p <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span> p <span class=\"token operator\">*</span> p <span class=\"token operator\">&lt;=</span> n<span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>p<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n         \n        <span class=\"token comment\">// Check if p is a prime factor.</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">%</span> p <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n             \n            <span class=\"token comment\">// If yes, then update n and result</span>\n            <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">%</span> p <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n                n <span class=\"token operator\">/=</span> p<span class=\"token punctuation\">;</span>\n                 \n            result <span class=\"token operator\">-=</span> result <span class=\"token operator\">/</span> p<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  \n    <span class=\"token comment\">// If n has a prime factor greater than sqrt(n)</span>\n    <span class=\"token comment\">// (There can be at-most one such prime factor)</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">></span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n        result <span class=\"token operator\">-=</span> result <span class=\"token operator\">/</span> n<span class=\"token punctuation\">;</span>\n         \n    <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3 id=\"특징\" style=\"position:relative;\"><a href=\"#%ED%8A%B9%EC%A7%95\" aria-label=\"특징 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>특징</h3>\n<ol>\n<li>p가 소수일 때, p^k의 오일러 피 함수의 값은</li>\n</ol>\n<p><img src=\"https://wikimedia.org/api/rest_v1/media/math/render/svg/a72a268fc759dddb08a75ea99641b8071f90ec38\" alt=\"https://wikimedia.org/api/rest_v1/media/math/render/svg/a72a268fc759dddb08a75ea99641b8071f90ec38\"></p>\n<ol>\n<li>소수 p의 오일러 피 함수의 값은</li>\n</ol>\n<p><img src=\"https://wikimedia.org/api/rest_v1/media/math/render/svg/4c0c04fbbc0accfa891e42552bcdb395604bba12\" alt=\"https://wikimedia.org/api/rest_v1/media/math/render/svg/4c0c04fbbc0accfa891e42552bcdb395604bba12\"></p>\n<h2 id=\"참조\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EC%A1%B0\" aria-label=\"참조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참조</h2>\n<p><a href=\"https://www.geeksforgeeks.org/eulers-totient-function/\">Euler’s Totient Function - GeeksforGeeks</a></p>\n<p><a href=\"https://ko.wikipedia.org/wiki/%EC%98%A4%EC%9D%BC%EB%9F%AC_%ED%94%BC_%ED%95%A8%EC%88%98\">오일러 피 함수 - 위키백과, 우리 모두의 백과사전 (wikipedia.org)</a></p>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#%ED%95%AD%EB%93%B1%EC%8B%9D\">항등식</a></p>\n<ul>\n<li><a href=\"#-%EC%98%88%EC%A0%9C\">📝 예제</a></li>\n<li><a href=\"#%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\">알고리즘</a></li>\n<li><a href=\"#%ED%8A%B9%EC%A7%95\">특징</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%B0%B8%EC%A1%B0\">참조</a></p>\n</li>\n</ul>\n</div>","frontmatter":{"date":"January 22, 2022","title":"Euler’s phi","categories":"Algorithm","author":"JaeseokWoo","emoji":"🧩"},"fields":{"slug":"/euler-phi/"}},"prev":null,"site":{"siteMetadata":{"siteUrl":"https://jaeseokwoo.github.io","comments":{"utterances":{"repo":"JaeseokWoo/JaeseokWoo.github.io"}}}}},"pageContext":{"slug":"/euclidean-algorithm/","nextSlug":"/euler-phi/","prevSlug":""}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}